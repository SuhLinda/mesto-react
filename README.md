Сдача проекта Mesto: портирование на «Реакт»
1. Ведите работу в новом репозитории

Как только вы перешли в урок проектной работы, удалённый репозиторий mesto-react скопировался в ваш аккаунт на «Гитхабе». После этого вы можете клонировать удалённый репозиторий на свой компьютер.
Для этого скопируйте адрес удалённого репозитория:
После того, как скопировали адрес удалённого репозитория — выполните команду для его клонирования:
git clone адрес_репозитория
После завершения работы над проектом не забудьте перед отправкой на проверку залить код на GitHub.

2. Создайте новый проект на Create React App

В этой проектной работе вы начнёте портировать проект Mesto на «Реакт».
После настройки и запуска нового проекта вы увидите стандартную заставку:

3. Портируйте разметку

Скопируйте HTML и конвертируйте его в JSX

В старом проекте был корневой элемент .page__content. Замените им содержимое компонента App. Не забывайте, что JSX и HTML — не совсем одно и то же.
Если вы всё сделали правильно, вы должны увидеть промежуточный результат:
Здорово, но могло бы быть и покрасивее. Кажется, нужно перенести стили.
Портируйте стили

Стили компонента App.css больше не понадобятся — этот файл можно удалить.
Скопируйте папки blocks, images и vendor из старого проекта. В новом проекте содержимое файла index.css замените на содержимое из pages/index.css:
image
Уже что-то, но не хватает логотипа. Импортируйте его правильным образом и подставьте полученный путь в JSX:

4. Вынесите первые компоненты

Пора начать наводить порядок в коде. Создайте папку src/components и перенесите в неё главный компонент приложения App.js.
Создайте новый файл Header.js и вынесите в него элемент <header> в виде отдельного компонента. Импортируйте и используйте этот компонент внутри App.
Аналогичным образом вынесите компоненты Main и Footer.
Отлично: мы немного «разгрузили» основной компонент App, хотя в нём всё ещё довольно много кода.
5. Настройте работу попапов

Добавьте императивные обработчики

Чтобы добавить первую интерактивность, а заодно проверить, правильно ли вы портировали разметку попапов, внутри компонента Main добавьте следующие обработчики:
handleEditAvatarClick
handleEditProfileClick
handleAddPlaceClick
Здесь мы немного схитрим: внутри этих обработчиков временно используйте привычный императивный подход (с querySelector и classList.add), чтобы задавать CSS-класс popup_is-opened элементу нужного попапа.
Теперь присвойте эти обработчики нужным элементам в JSX и убедитесь, что все три попапа открываются:
Вскоре вы сможете перейти к декларативному подходу, но сперва нужно всё подготовить.
Вынесите общий компонент попапов

Создайте компонент PopupWithForm и используйте его, чтобы вынести общий код следующих попапов:
«Редактировать профиль»
«Новое место»
«Обновить аватар»
«Вы уверены?»
В этих попапах много общей разметки: элементы внешнего и внутреннего контейнера, сама форма, заголовок и две кнопки. Вся общая разметка должна оказаться в новом компоненте. Извне должны будут передаваться только текст заголовка и идентификатор формы (в виде строк). Для этого добавьте соответствующие пропсы title и name и подставляйте их значения в JSX.
Замечание 1. Чтобы правильно подставить name в CSS-класс контейнера используйте следующую конструкцию:
className={`popup popup_type_${props.name}`}   
Замечание 2. Значение пропса name будет использоваться не только в имени CSS-класса контейнера, но и для атрибута name тега form.
Кроме заголовка и идентификатора в компонент PopupWithForm будет передаваться вложенное содержимое в виде JSX-разметки, отличающейся для всех четырёх попапов. Внутри самого компонента оно будет доступно через специальный пропс children, который также должен быть подставлен в нужном месте в JSX.
Вынесите компонент ImagePopup
Здесь всё просто, этот компонент пока не имеет пропсов и вложенного содержимого.
Декларативный подход

Начинается самое интересное. Для начала перенесите добавленные обработчики событий из компонента Main в компонент App. При этом, чтобы они продолжали вызываться из компонента Main, передавайте их в последний с помощью новых пропсов onEditProfile, onAddPlace и onEditAvatar.
Чтобы правильно реализовать декларативный подход, в компоненте App также должны появиться следующие переменные состояния, отвечающие за видимость трёх попапов:
isEditProfilePopupOpen
isAddPlacePopupOpen
isEditAvatarPopupOpen
Теперь вы можете заменить императивный код в обработчиках событий на код, который будет изменять значения соответствующих переменных состояния, задавая в них значение true.
Последнее, что нужно сделать, — добавить в компонент PopupWithForm пропc isOpen, на основе которого в JSX будет задаваться CSS-класс, отвечающий за видимость попапа.
Наконец, в коде App значение isOpen каждого из трёх попапов должно задаваться с помощью соответствующей переменной состояния.
Если вы всё сделали правильно, попапы снова должны открываться, но теперь они управляются стейт-переменными — самый настоящий декларативный подход!
Закрытие попапов

По аналогии со всеми предыдущими действиями реализуйте закрытие попапов. Вам поможет новый пропс onClose компонента PopupWithForm и его обработчик, который должен находиться внутри App и должен называться closeAllPopups.
6. Подключите API

Портируйте модуль API

Скопируйте файлы api.js и utils.js из старого проекта и положите их рядом в папке src/utils.
Прямо внутри api.js создайте экземпляр класса Api с нужными параметрами (включая ваш токен) и экспортируйте этот экземпляр вместо самого класса.
Используйте стейт для данных из API

В компоненте Main добавьте переменные состояния userName, userDescription и userAvatar. Используйте их в JSX.
Импортируйте модуль api и добавьте эффект, вызываемый при монтировании компонента, который будет совершать запрос в API за пользовательскими данными. После получения ответа задавайте полученные данные в соответствующие переменные состояния.
Замечание. Чтобы подставить URL аватара в контейнер используйте такой код:
style={{ backgroundImage: `url(${userAvatar})` }}
Ура! Наконец-то должны появиться ваши сохранённые данные:

Ещё немного, и вы сможете увидеть карточки добавленных мест.

7. Настройте карточки мест

Добавьте запрос к API

Добавьте ещё одну переменную стейта cards с пустым массивом в качестве значения по умолчанию. Добавьте второй запрос к API за соответствующими данными.
Из старого проекта скопируйте разметку карточки, находящуюся внутри тега template, и используйте её внутри JSX-итерации по массиву cards. Используйте подстановку данных элемента массива в JSX, чтобы вывести название карточки, количество лайков и указать URL изображения (как и прежде с помощью атрибута style).
Немного подождите, пока загрузятся данные...

Класс!
Вынесите компонент Card

Ничего особенного, просто поддерживаем порядок. Компонент может пока иметь всего один пропс card, в который целиком будет передаваться текущий элемент итерируемого массива.
Показывайте полноразмерную картинку при клике

Снова становится интересно. Чтобы отображать большую картинку при клике на карточку нужно сделать несколько вещей, которые вы уже делали на прошлых шагах.
В компоненте App добавьте стейт-переменную selectedCard. Значение этой переменной должно задаваться из нового обработчика handleCardClick и сбрасываться из уже существующего closeAllPopups.
Значение selectedCard должно передаваться с помощью пропса card в компонент ImagePopup, где оно будет использоваться для определения наличия CSS-класса видимости и задания адреса изображения в теге img. Также у ImagePopup должен появиться пропс onClose.
Обработчик handleCardClick должен вызываться из компонента Card. Для этого его нужно «пробросить» в компонент Card сквозь компонент Main — в виде пропса onCardClick. При этом, чтобы в него задавалось нужное значение с данными карточки, в компоненте Card должен появиться приблизительно такой код:
function handleClick() {
props.onCardClick(props.card);
}

Не забудьте проверить себя по чеклисту:
https://code.s3.yandex.net/web-developer/checklists-pdf/new-program/checklist-10.pdf

ССЫЛКА НА САЙТ https://suhlinda.github.io/mesto-react/